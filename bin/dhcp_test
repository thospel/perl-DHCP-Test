#!/usr/bin/perl -w
use strict;
use warnings;

use Getopt::Long 2.24 qw(:config bundling require_order);
use Socket
    qw(pack_sockaddr_in inet_aton inet_ntoa
       PF_INET SOCK_DGRAM SOL_SOCKET SO_REUSEADDR INADDR_ANY INADDR_BROADCAST
       SO_BROADCAST);
use Sys::Hostname qw(hostname);

# Client chosen ID to match answers
# my $xid = "ABCD";
my $xid = "41.42.43.44";
my $mac = "00:25:90:a2:cf:e4";
my $hostname = hostname();
my $client_ip = "10.253.0.8";
my $separator = "===============";

die "Could not parse your command line. Try $0 -h\n" unless
    GetOptions("v|verbose!"	=> \my $verbose,
               "xid=s"		=> \$xid,
               "i|interface=s"	=> \my $interface,
               "m|mac=s"	=> \$mac,
               "H|hostname=s"	=> \$hostname,
               "g|gateway=s"	=> \my $gateway_ip,
               "s|server=s"	=> \my $server_ip,
               "version!"	=> \my $version,
               "U|unsafe!"	=> \my $unsafe,
               "h|help!"	=> \my $help);
$xid = unpack("N", inet_aton($xid));
my @mac = map hex, split /:/, $mac;
@mac == 6 || die "Invalid MAC length";
$_ <= 0xff || die "Invalid value in MAC" for @mac;
$mac = pack("W*", @mac);
my $server_addr = inet_aton($server_ip || "255.255.255.255") ||
    die "Could not resolve $server_ip";

use constant {
    SO_BINDTODEVICE	=> 25,

    COOKIE		=> 0x63825363,
    DISCOVER		=> 1,
    OFFER		=> 2,
    REPLY		=> 3,
    ACK			=> 5,
    NAK			=> 6,
    FLAG_BROADCAST	=> 0x8000,
    PACKET_SIZE		=> 300,

    # DHCP Options
    OPTION_MASK		=> 1,
    OPTION_ROUTER	=> 3,
    OPTION_DNS		=> 6,
    OPTION_HOSTNAME	=> 12,
    OPTION_DOMAIN	=> 15,
    OPTION_BROADCAST	=> 28,
    OPTION_NTP		=> 42,
    OPTION_REQUEST_IP	=> 50,
    OPTION_LEASE_TIME	=> 51,
    OPTION_TYPE		=> 53,
    OPTION_SERVER	=> 54,
    OPTION_REQUEST_LIST	=> 55,
    OPTION_MESSAGE	=> 56,
    OPTION_RENEWAL_TIME	=> 58,
    OPTION_REBIND_TIME	=> 59,
    OPTION_END		=> 255,

    # Request list
    REQUEST_SUBNET		=>   1,
    REQUEST_TIME		=>   2,
    REQUEST_ROUTER		=>   3,
    REQUEST_DNS			=>   6,
    REQUEST_HOSTNAME		=>  12,
    REQUEST_DOMAIN		=>  15,
    REQUEST_BROADCAST		=>  28,
    REQUEST_NTP			=>  42,
    REQUEST_NETBIOS_NS		=>  44,
    REQUEST_NETBIOS_SCOPE	=>  47,
    REQUEST_MTU			=>  26,
    REQUEST_DOMAIN_SEARCH	=> 119,
    REQUEST_ROUTE_STATIC	=> 121,
};

my $request_list =
    pack("W*",
         REQUEST_SUBNET,
         REQUEST_BROADCAST,
         REQUEST_TIME,
         REQUEST_ROUTER,
         REQUEST_DOMAIN,
         REQUEST_DNS,
         REQUEST_DOMAIN_SEARCH,
         REQUEST_HOSTNAME,
         REQUEST_NETBIOS_NS,
         REQUEST_NETBIOS_SCOPE,
         REQUEST_MTU,
         REQUEST_ROUTE_STATIC,
         REQUEST_NTP);

my $PROTO_UDP = getprotobyname("udp") // 17;
my $bootps = getservbyname("bootps", "udp") // 67;
my $bootpc = getservbyname("bootpc", "udp") // 68;

sub packet_build {
    my ($type, $client_address, $server_address) = @_;
    my @options = (
        OPTION_TYPE, pack("W", $type),
        OPTION_HOSTNAME, $hostname,
        OPTION_REQUEST_LIST, $request_list,
    );
    push @options, OPTION_REQUEST_IP, $client_address if $client_address;
    push @options, OPTION_SERVER,     $server_address if $server_address;
    my $n = @options / 2;
    my $buffer = pack("W4Nnnx4x4x4a4a16x192N(WW/a*)${n}W",
		      1,	# Boot request
		      1,	# Hardware type (ethernet)
		      6,	# Hardware addr length (6 bytes) <= 16
		      0,	# Max Hops
		      $xid,
		      0,	# secs
                      FLAG_BROADCAST, # flags
                      $gateway_ip ? inet_aton($gateway_ip) : INADDR_ANY,
                      $mac,
                      COOKIE,
                      @options,
                      OPTION_END
                  );
    my $pad = PACKET_SIZE - length $buffer;
    die "Packet too long" if $pad < 0;
    return $buffer . "\x0" x $pad;
}

sub packet_receive {
    my ($socket) = @_;

    my $rc = sysread($socket, my $buffer, int(2**16));
    defined $rc || die "Could not sysread: $^E";
    $rc || die "Assertion: Empty sysread";
    # print "Reply length $rc\n";

    my ($op, $hw_type, $hw_len, $hops,
        $reply_xid, $secs, $flags,
        $client_addr, $your_addr, $server_addr, $gateway_addr,
        $hw_addr, $cookie,$options)
        = unpack("W4Nnna4a4a4a4a16x192Na*", $buffer);
    $op == 2 || die "Unexpected boot reply type $op";
    $cookie == COOKIE || die "Invalid cookie $cookie";
    $reply_xid == $xid || die "Inconsistent xid: $reply_xid vs $xid";
    my %option = (
        xid		=> $reply_xid,
        xid_ip		=> inet_ntoa(pack("N", $reply_xid)),
        client_addr	=> $client_addr,
        your_addr	=> $your_addr,
        server_addr	=> $server_addr,
        gateway_addr	=> $gateway_addr,
    );
    defined $options || die "Truncated DHCP reply";
    $option{client_ip} = inet_ntoa($client_addr);
    $option{your_ip} = inet_ntoa($your_addr);
    $option{server_ip} = inet_ntoa($server_addr);
    $option{gateway_ip} = inet_ntoa($gateway_addr);
    $option{hw_addr} = substr($hw_addr, 0, $hw_len);
    my $hw = unpack("H*", $option{hw_addr});
    $hw =~ s/(..)\B/$1:/g;
    print <<"EOF" if $verbose
$separator
op=$op, hw_type=$hw_type, hw_len=$hw_len, hops=$hops
xid=$option{xid_ip} secs=$secs, flags=$flags
client IP $option{client_ip}
Your   IP $option{your_ip}
Server IP $option{server_ip}
Gate   IP $option{gateway_ip}
MAC $hw
EOF
        ;
    while ($options ne "") {
        my $type = ord substr($options, 0, 1, "");
        next if $type == 0;
        last if $type == OPTION_END;
        my ($value, $pos) = unpack("W/a*.", $options);
        if ($type == OPTION_TYPE) {
            length $value == 1 || die "Unexpected DHCP message type length";
            $option{reply_type} = unpack("W", $value);
        } elsif ($type == OPTION_REBIND_TIME) {
            length $value == 4 || die "Unexpected REBIND_TIME length";
            $option{rebind_time} = unpack("N", $value);
            print "Rebind Time: $option{rebind_time}\n" if $verbose;
        } elsif ($type == OPTION_RENEWAL_TIME) {
            length $value == 4 || die "Unexpected RENEWAL_TIME length";
            $option{renewal_time} = unpack("N", $value);
            print "Renewal Time: $option{renewal_time}\n" if $verbose;
        } elsif ($type == OPTION_LEASE_TIME) {
            length $value == 4 || die "Unexpected LEASE_TIME length";
            $option{lease_time} = unpack("N", $value);
            print "Lease Time: $option{lease_time}\n" if $verbose;
        } elsif ($type == OPTION_MASK) {
            length $value == 4 || die "Unexpected MASK length";
            $option{mask} = inet_ntoa($value);
            print "Mask: $option{mask}\n" if $verbose;
        } elsif ($type == OPTION_BROADCAST) {
            length $value == 4 || die "Unexpected braodcast length";
            $option{broadcast} = inet_ntoa($value);
            print "Broadcast: $option{broadcast}\n" if $verbose;
        } elsif ($type == OPTION_ROUTER) {
            length $value == 4 || die "Unexpected ROUTER length";
            $option{router} = inet_ntoa($value);
            print "Router: $option{router}\n" if $verbose;
        } elsif ($type == OPTION_NTP) {
            # Probably needs a loop to handle multiple NTP instead
            length $value == 4 || die "Unexpected NTP length";
            $option{ntp} = inet_ntoa($value);
            print "NTP: $option{ntp}\n" if $verbose;
        } elsif ($type == OPTION_DNS) {
            # Probably needs a loop to handle multiple DNS instead
            length $value == 4 || die "Unexpected DNS length";
            $option{dns} = inet_ntoa($value);
            print "DNS: $option{dns}\n" if $verbose;
        } elsif ($type == OPTION_DOMAIN) {
            $option{domain} = $value;
            print "Domain: $option{domain}:\n" if $verbose;
        } elsif ($type == OPTION_SERVER) {
            $server_addr eq $value || die "Inconsistent server";
            $option{server} = $value;
        } elsif ($type == OPTION_MESSAGE) {
            $option{message} = $value;
            print "Message: $option{message}:\n" if $verbose;
        } else {
            $value = unpack("H*", $value);
            print "Option $type: $value\n" if $verbose;
        }
        substr($options, 0, $pos, "");
    }
    exists $option{reply_type} || die "No reply type";
    return \%option;
}

socket(my $sender, PF_INET, SOCK_DGRAM, $PROTO_UDP) ||
    die "Could not create socket: $^E";

# Autoflush $sender
my $fh = select($sender);
$|=1;
select($fh);

setsockopt($sender, SOL_SOCKET, SO_REUSEADDR, 1) ||
    die "Could not setsockopt SO_REUSEADDR: $^E";
setsockopt($sender, SOL_SOCKET, SO_BROADCAST, 1) ||
    die "Could not setsockopt SO_BROADCAST: $^E";
setsockopt($sender, SOL_SOCKET, SO_BINDTODEVICE, pack("Z*", $interface)) ||
    die "Could not setsockopt SO_BINDTODEVICE: $^E" if $interface;
my $from = pack_sockaddr_in($bootpc, INADDR_ANY);
my $to   = pack_sockaddr_in($bootps, $server_addr);
# bind($sender, $from) or die "Could not bind: $^E";
connect($sender, $to) or die "Could not connect: $^E";
# DISCOVER
print $sender packet_build(DISCOVER);

socket(my $recv, PF_INET, SOCK_DGRAM, $PROTO_UDP) ||
    die "Could not create socket: $^E";
setsockopt($recv, SOL_SOCKET, SO_BROADCAST, 1) ||
    die "Could not setsockopt SO_BROADCAST: $^E";
bind($recv, $from) or die "Could not bind: $^E";

# OFFER
my $options = packet_receive($recv);
$options->{reply_type} == OFFER ||
    die "Unexpected reply type $options->{reply_type} (expected OFFER)";

$xid = int(($xid+1) % 2**32);
# REQUEST
print $sender packet_build(REPLY,
                           $options->{your_addr},
                           $options->{server_addr});

# ACK
$options = packet_receive($recv);
$options->{reply_type} == ACK ||
    die "Unexpected reply type $options->{reply_type} (expected ACK)";
print "$separator\n" if $verbose;
print "DHCP Server $options->{server_ip} gave out $options->{your_ip}\n";
