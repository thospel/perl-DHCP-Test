#!/usr/bin/perl -w
# RFC2131: DHCP
# RFC2132: Options
use strict;
use warnings;

our $VERSION = "1.000";

use FindBin qw($Script);
our $Bin;

# If the program runs as /foobar/bin/program, find libraries in /foobar/lib
BEGIN {
    # Even on windows FindBin uses / in the reported path
    $Bin = $FindBin::Bin;
    $Bin =~ s{/+\z}{};
    $Bin =~
        ($^O eq "MSWin32" ?
         qr{^((?:[A-Z]:)?(?:/[a-zA-Z0-9_:.~ -]+)*)/[a-zA-Z0-9_.-]+/*\z} :
         qr{^((?:/[a-zA-Z0-9_:.-]+)*)/[a-zA-Z0-9_.-]+/*\z}) ||
         die "Could not parse bin directory '$Bin'";
    # Use untainted version of lib
    require lib;
    # Support a simple --blib option for pre-install testing
    "lib"->import(@ARGV && $ARGV[0] eq "--blib" ? shift && "$1/blib/lib" : "$1/lib");
}

use Getopt::Long 2.24 qw(:config bundling require_order);
use Socket
    qw(pack_sockaddr_in inet_aton
       PF_INET SOCK_DGRAM SOL_SOCKET SO_REUSEADDR INADDR_ANY INADDR_BROADCAST
       SO_BROADCAST);
use Sys::Hostname qw(hostname);

use DHCP::Test qw($verbose $separator
                  SO_BINDTODEVICE DISCOVER OFFER REPLY ACK
                  OPTION_HOSTNAME OPTION_REQUEST_IP OPTION_SERVER
                  packet_build packet_receive);

# Client chosen ID to match answers
# my $xid = "41.42.43.44";
my $xid = ($$ % 2**16) << 16 | int(rand 2**15) << 1;
my $mac = "00:25:90:a2:cf:e4";
my $hostname = hostname();
my $client_ip = "10.253.0.8";

die "Could not parse your command line. Try $0 -h\n" unless
    GetOptions("v|verbose!"	=> \$verbose,
               "xid=s"		=> \$xid,
               "i|interface=s"	=> \my $interface,
               "m|mac=s"	=> \$mac,
               "H|hostname=s"	=> \$hostname,
               # do DHCP relay request. Answer is on port 67. Not supported yet
               "g|gateway=s"	=> \my $gateway_ip,
               # Do not broadcast but send to specific DHCP server
               "s|server=s"	=> \my $server_ip,
               # Only accept answer from specific DHCP server
               "e|expect=s"	=> \my $expect_ip,
               "version!"	=> \my $version,
               "U|unsafe!"	=> \my $unsafe,
               "h|help!"	=> \my $help);
my $expect_addr = defined $expect_ip ?
    inet_aton($expect_ip) || die("Cannot parse $expect_ip") :
    undef;
$xid = unpack("N", inet_aton($xid));
my @mac = map hex, split /:/, $mac;
@mac == 6 || die "Invalid MAC length";
$_ <= 0xff || die "Invalid value in MAC" for @mac;
$mac = pack("W*", @mac);
my $server_addr = inet_aton($server_ip || "255.255.255.255") ||
    die "Could not resolve $server_ip";

my $PROTO_UDP = getprotobyname("udp") // 17;
my $bootps = getservbyname("bootps", "udp") // 67;
my $bootpc = getservbyname("bootpc", "udp") // 68;

socket(my $sender, PF_INET, SOCK_DGRAM, $PROTO_UDP) ||
    die "Could not create socket: $^E";

# Autoflush $sender
my $fh = select($sender);
$|=1;
select($fh);

setsockopt($sender, SOL_SOCKET, SO_REUSEADDR, 1) ||
    die "Could not setsockopt SO_REUSEADDR: $^E";
setsockopt($sender, SOL_SOCKET, SO_BROADCAST, 1) ||
    die "Could not setsockopt SO_BROADCAST: $^E";
setsockopt($sender, SOL_SOCKET, SO_BINDTODEVICE, pack("Z*", $interface)) ||
    die "Could not setsockopt SO_BINDTODEVICE: $^E" if $interface;
my $from = pack_sockaddr_in($bootpc, INADDR_ANY);
my $to   = pack_sockaddr_in($bootps, $server_addr);
# bind($sender, $from) or die "Could not bind: $^E";
connect($sender, $to) or die "Could not connect: $^E";
# DISCOVER
print $sender packet_build(DISCOVER, $xid, $gateway_ip, $mac,
                           hostname => $hostname);

socket(my $recv, PF_INET, SOCK_DGRAM, $PROTO_UDP) ||
    die "Could not create socket: $^E";
setsockopt($recv, SOL_SOCKET, SO_BROADCAST, 1) ||
    die "Could not setsockopt SO_BROADCAST: $^E";
bind($recv, $from) or die "Could not bind: $^E";

# OFFER
my $options = packet_receive($recv, $xid, undef, $mac);
$options->{message_type} == OFFER ||
    die "Unexpected reply type $options->{message_type} (expected OFFER)";

$xid = int(($xid+1) % 2**32);
# REQUEST
print $sender packet_build(REPLY, $xid, $gateway_ip, $mac,
                           hostname	=> $hostname,
                           request_ip	=> $options->{your_ip},
                           server	=> $options->{server_addr});

# ACK
$options = packet_receive($recv, $xid, $options->{server}, $mac);
$options->{message_type} == ACK ||
    die "Unexpected reply type $options->{message_type} (expected ACK)";
print "$separator\n" if $verbose;
print "DHCP Server $options->{server_ip} gave out $options->{your_ip}\n";
