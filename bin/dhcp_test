#!/usr/bin/perl -w
use strict;
use warnings;

use Getopt::Long 2.24 qw(:config bundling require_order);
use Socket
    qw(pack_sockaddr_in inet_aton inet_ntoa
       PF_INET SOCK_DGRAM SOL_SOCKET SO_REUSEADDR INADDR_ANY INADDR_BROADCAST
       SO_BROADCAST);
use Sys::Hostname qw(hostname);

# Client chosen ID to match answers
# my $xid = "41.42.43.44";
my $xid = ($$ % 2**16) << 16 | int(rand 2**15) << 1;
my $mac = "00:25:90:a2:cf:e4";
my $hostname = hostname();
my $client_ip = "10.253.0.8";
my $separator = "===============";

die "Could not parse your command line. Try $0 -h\n" unless
    GetOptions("v|verbose!"	=> \my $verbose,
               "xid=s"		=> \$xid,
               "i|interface=s"	=> \my $interface,
               "m|mac=s"	=> \$mac,
               "H|hostname=s"	=> \$hostname,
               # do DHCP relay request. Answer is on port 67. Not supported yet
               "g|gateway=s"	=> \my $gateway_ip,
               # Do not broadcast but send to specific DHCP server
               "s|server=s"	=> \my $server_ip,
               # Only accept answer from specific DHCP server
               "e|expect=s"	=> \my $expect_ip,
               "version!"	=> \my $version,
               "U|unsafe!"	=> \my $unsafe,
               "h|help!"	=> \my $help);
my $expect_addr = defined $expect_ip ?
    inet_aton($expect_ip) || die("Cannot parse $expect_ip") :
    undef;
$xid = unpack("N", inet_aton($xid));
my @mac = map hex, split /:/, $mac;
@mac == 6 || die "Invalid MAC length";
$_ <= 0xff || die "Invalid value in MAC" for @mac;
$mac = pack("W*", @mac);
my $server_addr = inet_aton($server_ip || "255.255.255.255") ||
    die "Could not resolve $server_ip";

use constant {
    SO_BINDTODEVICE	=> 25,

    COOKIE		=> 0x63825363,
    DISCOVER		=> 1,
    OFFER		=> 2,
    REPLY		=> 3,
    ACK			=> 5,
    NAK			=> 6,
    FLAG_BROADCAST	=> 0x8000,
    PACKET_SIZE		=> 300,

    # DHCP Options
    OPTION_MASK		=> 1,
    OPTION_ROUTER	=> 3,
    OPTION_DNS		=> 6,
    OPTION_HOSTNAME	=> 12,
    OPTION_DOMAIN	=> 15,
    OPTION_BROADCAST	=> 28,
    OPTION_NTP		=> 42,
    OPTION_REQUEST_IP	=> 50,
    OPTION_LEASE_TIME	=> 51,
    OPTION_TYPE		=> 53,
    OPTION_SERVER	=> 54,
    OPTION_REQUEST_LIST	=> 55,
    OPTION_MESSAGE	=> 56,
    OPTION_RENEWAL_TIME	=> 58,
    OPTION_REBIND_TIME	=> 59,
    OPTION_END		=> 255,

    TYPE_ADDR		=> 1,
    TYPE_IP		=> 2,
    TYPE_IPS		=> 3,
    TYPE_STRING		=> 4,
    TYPE_UINT		=> 5,
    TYPE_UINT8		=> 6,
    TYPE_UINT8S		=> 7,

    # Request list
    REQUEST_SUBNET		=>   1,
    REQUEST_TIME		=>   2,
    REQUEST_ROUTER		=>   3,
    REQUEST_DNS			=>   6,
    REQUEST_HOSTNAME		=>  12,
    REQUEST_DOMAIN		=>  15,
    REQUEST_BROADCAST		=>  28,
    REQUEST_NTP			=>  42,
    REQUEST_NETBIOS_NS		=>  44,
    REQUEST_NETBIOS_SCOPE	=>  47,
    REQUEST_MTU			=>  26,
    REQUEST_DOMAIN_SEARCH	=> 119,
    REQUEST_ROUTE_STATIC	=> 121,
};

my $request_list =
    pack("W*",
         REQUEST_SUBNET,
         REQUEST_BROADCAST,
         REQUEST_TIME,
         REQUEST_ROUTER,
         REQUEST_DOMAIN,
         REQUEST_DNS,
         REQUEST_DOMAIN_SEARCH,
         REQUEST_HOSTNAME,
         REQUEST_NETBIOS_NS,
         REQUEST_NETBIOS_SCOPE,
         REQUEST_MTU,
         REQUEST_ROUTE_STATIC,
         REQUEST_NTP);

my %option_types = (
    OPTION_MASK()		=> [TYPE_IP, "mask"],
    OPTION_ROUTER()		=> [TYPE_IP, "router"],
    OPTION_DNS()		=> [TYPE_IPS, "dns", "DNS"],
    OPTION_HOSTNAME()		=> [TYPE_STRING, "hostname"],
    OPTION_DOMAIN()		=> [TYPE_STRING, "domain"],
    OPTION_BROADCAST()		=> [TYPE_IP, "braodcast"],
    OPTION_NTP()		=> [TYPE_IPS, "ntp", "NTP"],
    OPTION_REQUEST_IP()		=> [TYPE_IP, "client_address"],
    OPTION_LEASE_TIME()		=> [TYPE_UINT, "lease_time"],
    OPTION_TYPE()		=> [TYPE_UINT8, "reply_type", ""],
    OPTION_SERVER()		=> [TYPE_ADDR, "server", ""],
    OPTION_REQUEST_LIST()	=> [TYPE_UINT8S, "request_list"],
    OPTION_MESSAGE()		=> [TYPE_STRING, "message"],
    OPTION_RENEWAL_TIME()	=> [TYPE_UINT, "renewal_time"],
    OPTION_REBIND_TIME()	=> [TYPE_UINT, "renewal_time"],
);

my $PROTO_UDP = getprotobyname("udp") // 17;
my $bootps = getservbyname("bootps", "udp") // 67;
my $bootpc = getservbyname("bootpc", "udp") // 68;

sub packet_build {
    my ($type, $client_address, $server_address) = @_;
    my @options = (
        OPTION_TYPE, pack("W", $type),
        OPTION_HOSTNAME, $hostname,
        # OPTION_REQUEST_LIST, $request_list,
    );
    push @options, OPTION_REQUEST_IP, $client_address if $client_address;
    push @options, OPTION_SERVER,     $server_address if $server_address;
    my $n = @options / 2;
    my $buffer = pack("W4Nnnx4x4x4a4a16x192N(WW/a*)${n}W",
		      1,	# Boot request
		      1,	# Hardware type (ethernet)
		      6,	# Hardware addr length (6 bytes) <= 16
		      0,	# Max Hops
		      $xid,
		      0,	# secs
                      FLAG_BROADCAST, # flags
                      $gateway_ip ? inet_aton($gateway_ip) : INADDR_ANY,
                      $mac,
                      COOKIE,
                      @options,
                      OPTION_END
                  );
    my $pad = PACKET_SIZE - length $buffer;
    die "Packet too long" if $pad < 0;
    return $buffer . "\x0" x $pad;
}

sub packet_receive {
    my ($socket) = @_;

    while (1) {
        my $rc = sysread($socket, my $buffer, int(2**16));
        defined $rc || die "Could not sysread: $^E";
        $rc || die "Assertion: Empty sysread";
        # print "Reply length $rc\n";

        my ($op, $hw_type, $hw_len, $hops,
            $reply_xid, $secs, $flags,
            $client_addr, $your_addr, $server_addr, $gateway_addr,
            $hw_addr, $cookie,$options)
            = unpack("W4Nnna4a4a4a4a16x192Na*", $buffer);
        $op == 2 || die "Unexpected boot reply type $op";
        $cookie == COOKIE || next;
        $reply_xid == $xid || next;
        !$expect_addr || $server_addr eq $expect_addr || next;
        my %option = (
            xid		=> $reply_xid,
            xid_ip	=> inet_ntoa(pack("N", $reply_xid)),
            client_addr	=> $client_addr,
            your_addr	=> $your_addr,
            server_addr	=> $server_addr,
            gateway_addr=> $gateway_addr,
        );
        defined $options || die "Truncated DHCP reply";
        $option{client_ip} = inet_ntoa($client_addr);
        $option{your_ip} = inet_ntoa($your_addr);
        $option{server_ip} = inet_ntoa($server_addr);
        $option{gateway_ip} = inet_ntoa($gateway_addr);
        $option{hw_addr} = substr($hw_addr, 0, $hw_len);
        my $hw = unpack("H*", $option{hw_addr});
        $hw =~ s/(..)\B/$1:/g;
        print <<"EOF" if $verbose
$separator
op=$op, hw_type=$hw_type, hw_len=$hw_len, hops=$hops
xid=$option{xid_ip} secs=$secs, flags=$flags
client IP $option{client_ip}
Your   IP $option{your_ip}
Server IP $option{server_ip}
Gate   IP $option{gateway_ip}
MAC $hw
EOF
            ;
        while ($options ne "") {
            my $type = ord substr($options, 0, 1, "");
            next if $type == 0;
            last if $type == OPTION_END;
            my ($value, $pos) = unpack("W/a*.", $options);
            if (my $option_type = $option_types{$type}) {
                my ($otype, $name, $disply_name) = @$option_type;
                if (!defined $disply_name) {
                    $disply_name = ucfirst($name);
                    $disply_name =~ s/_(.)/ \u$1/g;
                }
                if ($otype == TYPE_IP) {
                    length $value == 4 || die "Unexpected $name length";
                    $option{$name} = inet_ntoa($value);
                } elsif ($otype == TYPE_IPS) {
                    length($value) % 4 == 0 || die "Unexpected $name length";
                    $option{$name} = [map inet_ntoa($_), unpack("(a4)*", $value)];
                } elsif ($otype == TYPE_ADDR) {
                    length $value == 4 || die "Unexpected $name length";
                    $option{$name} = $value;
                } elsif ($otype == TYPE_STRING) {
                    $option{$name} = $value;
                } elsif ($otype == TYPE_UINT) {
                    length $value == 4 || die "Unexpected $name length";
                    $option{$name} = unpack("N", $value);
                } elsif ($otype == TYPE_UINT8) {
                    length $value == 1 || die "Unexpected $name length";
                    $option{$name} = unpack("W", $value);
                } else {
                    die "Assertion: Unimplemented option type $option_type->[0]";
                }
                if ($verbose && $disply_name ne "") {
                    if (ref $option{$name} eq "ARRAY") {
                        print "$disply_name: @{$option{$name}}\n";
                    } else {
                        print "$disply_name: $option{$name}\n";
                    }
                }
            } else {
                $value = unpack("H*", $value);
                print "Option $type: $value\n" if $verbose;
            }
            substr($options, 0, $pos, "");
        }
        !exists $option{server} || $option{server} eq $server_addr ||
            die "Inconsistent server";
        exists $option{reply_type} || die "No reply type";
        return \%option;
    }
}

socket(my $sender, PF_INET, SOCK_DGRAM, $PROTO_UDP) ||
    die "Could not create socket: $^E";

# Autoflush $sender
my $fh = select($sender);
$|=1;
select($fh);

setsockopt($sender, SOL_SOCKET, SO_REUSEADDR, 1) ||
    die "Could not setsockopt SO_REUSEADDR: $^E";
setsockopt($sender, SOL_SOCKET, SO_BROADCAST, 1) ||
    die "Could not setsockopt SO_BROADCAST: $^E";
setsockopt($sender, SOL_SOCKET, SO_BINDTODEVICE, pack("Z*", $interface)) ||
    die "Could not setsockopt SO_BINDTODEVICE: $^E" if $interface;
my $from = pack_sockaddr_in($bootpc, INADDR_ANY);
my $to   = pack_sockaddr_in($bootps, $server_addr);
# bind($sender, $from) or die "Could not bind: $^E";
connect($sender, $to) or die "Could not connect: $^E";
# DISCOVER
print $sender packet_build(DISCOVER);

socket(my $recv, PF_INET, SOCK_DGRAM, $PROTO_UDP) ||
    die "Could not create socket: $^E";
setsockopt($recv, SOL_SOCKET, SO_BROADCAST, 1) ||
    die "Could not setsockopt SO_BROADCAST: $^E";
bind($recv, $from) or die "Could not bind: $^E";

# OFFER
my $options = packet_receive($recv);
$options->{reply_type} == OFFER ||
    die "Unexpected reply type $options->{reply_type} (expected OFFER)";

$xid = int(($xid+1) % 2**32);
# REQUEST
print $sender packet_build(REPLY,
                           $options->{your_addr},
                           $options->{server_addr});

# ACK
$options = packet_receive($recv);
$options->{reply_type} == ACK ||
    die "Unexpected reply type $options->{reply_type} (expected ACK)";
print "$separator\n" if $verbose;
print "DHCP Server $options->{server_ip} gave out $options->{your_ip}\n";
