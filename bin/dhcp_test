#!/usr/bin/perl -w
# RFC2131: DHCP
# RFC2132: Options
use strict;
use warnings;

=begin comment
On 10.253.0.8

# Set up FOU tunnel. Notice that we listen on the output port of the tunnel
ip link add name fou1 type ipip remote 127.0.0.1 local 127.0.0.1 ttl 225 encap fou encap-sport auto encap-dport 1236
ip addr add 10.253.4.1/24 dev fou1
# Decapsulator
ip fou add port 1237 ipproto 4 local 127.0.0.1

# Allow these weird outgoing FOU packets
sysctl -w net.ipv4.conf.all.rp_filter=0
sysctl -w net.ipv4.conf.fou1.rp_filter=0

# Match DHCP replies about MAC address 00:00:6C:XX:XX:XX
# Leave operational DHCP replies alone
iptables -t mangle -A OUTPUT -p udp --dport 67 --sport 67 -m u32 --u32 "4&0x1FFF=0 && 0>>22&0x3C@35&0xffffff=0x6c" -j MARK --set-mark 17

# Make marked packets use routing plane 101
ip rule add fwmark 17 lookup 101

# Route everything in routing plane 101 to the FOU tunnel:
# ip route add default via 10.253.4.1 table 101

# Experiments with -t nat failed because this implicitely uses tracked
# connections and all these port 67 to port 67 packets fall into the same
# connection. And since the nat is only done on the first packet for the tracked
# connection it means that effectively the the MAC match gets ignored

# Now this works (on 10.253.0.8):
dhcp_test -v -g 10.254.0.14  -s 0.0.0.1 -l 1236 -r 0 -e 10.253.0.8 -m 00:00:6C --fou 1237
# Notice that -s <local address> like 0.0.0.0, 255.255.255.255, 10.235.0.8 etc
# all fail. The reason is unclear. The DHCPDISCOVER packet is generated (you
# can tcpdump it on interface fou1, and strace shows that the DHCP server
# receives it, but it gets ignored. It seems that any visible IP address fails
# you must use something that isn't assigned to any host for -s to work.
# This needs to be traced in the dhcp executable to understand this

# Experiments with tc filter nat also failed. It works for a specific -g target
# but I seem to be unable to map a range of destination addresses to a single
# destination address. I always get a mask of /32 however I add the filter
# Either I do something wrong or its a bug or what I want is impossible:
#
# ptables -t mangle -A OUTPUT -p udp --dport 67 --sport 67 -m u32 --u32 "4&0x1FFF=0 && 0>>22&0x3C@35&0xffffff=0x6c" -j MARK --set-mark 18
# tc qdisc del add eno1 root handle 1 htb
# tc filter add dev eno1 parent 1: protocol ip prio 8 handle 18 fw action nat ingress any 10.253.0.14/16
# tc filter show dev eno1

# nftables should be abnle to do static NAT, but my system is currently iptables

=end comment

=cut

our $VERSION = "1.000";

use FindBin qw($Script);
our $Bin;

# If the program runs as /foobar/bin/program, find libraries in /foobar/lib
BEGIN {
    # Even on windows FindBin uses / in the reported path
    $Bin = $FindBin::Bin;
    $Bin =~ s{/+\z}{};
    $Bin =~
        ($^O eq "MSWin32" ?
         qr{^((?:[A-Z]:)?(?:/[a-zA-Z0-9_:.~ -]+)*)/[a-zA-Z0-9_.-]+/*\z} :
         qr{^((?:/[a-zA-Z0-9_:.-]+)*)/[a-zA-Z0-9_.-]+/*\z}) ||
         die "Could not parse bin directory '$Bin'";
    # Use untainted version of lib
    require lib;
    # Support a simple --blib option for pre-install testing
    "lib"->import(@ARGV && $ARGV[0] eq "--blib" ? shift && "$1/blib/lib" : "$1/lib");
}

use Getopt::Long 2.24 qw(:config bundling require_order);
use Socket
    qw(pack_sockaddr_in unpack_sockaddr_in inet_aton inet_ntoa
       PF_INET SOCK_DGRAM SO_REUSEADDR INADDR_ANY INADDR_BROADCAST);
use Sys::Hostname qw(hostname);

use DHCP::Test qw($verbose $separator
                  SO_BINDTODEVICE PROTO_UDP BOOTPC BOOTPS
                  DISCOVER OFFER REQUEST ACK RELEASE
                  OPTION_HOSTNAME OPTION_REQUEST_IP OPTION_SERVER
                  parse_address packet_send packet_receive);
use DHCP::Test::Package;

# Client chosen ID to match answers
# my $xid = "41.42.43.44";
my $xid = ($$ % 2**16) << 16 | int(rand 2**15) << 1;
my $hostname_local = hostname();
$hostname_local =~ s/\..*//sg;
my $timeout = 1.2;
my $retries = 3;

die "Could not parse your command line. Try $0 -h\n" unless
    GetOptions("v|verbose!"	=> \$verbose,
               "xid=s"		=> \$xid,
               "r|retries=o"	=> \$retries,
               "t|timeout=f"	=> \$timeout,
               "i|interface=s"	=> \my $interface,
               "m|mac:s"	=> \my $mac,
               "H|hostname:s"	=> \my $hostname,
               "l|listen=s"	=> \my $listen,
               # do DHCP relay request. Answer is on port 67. Not supported yet
               "g|gateway:s"	=> \my $gateway_ip,
               "u|unicast!"	=> \my $unicast,
               "b|broadcast!"	=> \my $broadcast,
               "T|track!"	=> \my $track,
               # Do not broadcast but send to specific DHCP server
               "s|server=s"	=> \my $server_ip,
               # Only accept answer from specific DHCP server
               "e|expect=s"	=> \my $expect_ip,
               "k|keep!"	=> \my $keep,
               "fou=s"		=> \my $fou,
               "version!"	=> \my $version,
               "U|unsafe!"	=> \my $unsafe,
               "h|help!"	=> \my $help);

if ($version) {
    ## no critic (UselessNoCritic RequireCheckedSyscalls)
    print<<"EOF";
dhcp_test $VERSION (DHCP::Test $DHCP::Test::Package::VERSION)
EOF
    exit 0;
}
if ($help) {
    require Config;
    $ENV{PATH} .= ":" unless $ENV{PATH} eq "";
    $ENV{PATH} = "$ENV{PATH}$Config::Config{'installscript'}";
    exit system("perldoc", "-F", $unsafe ? "-U" : (), "$Bin/$Script") ? 1 : 0;
    # make parser happy
    %Config::Config = ();
}

$hostname = $hostname_local if defined $hostname && $hostname eq "";
my $expect_addr = defined $expect_ip ?
    inet_aton($expect_ip) || die("Could not resolve expect IP '$expect_ip'") :
    undef;
$xid = unpack("N", inet_aton($xid) // die "Could not resolve xid '$xid'");
if (defined $mac) {
    $mac =~ /^[0-9A-F:. ]*\z/i || die "Invalid MAC '$mac'\n";
    $mac =~ s{([0-9A-F]+)}{length($1) % 2 ? "0$1" : $1}eig;
    $mac =~ tr/:. //d;
    $mac = pack("H*", $mac);
    if (length $mac != 6) {
        length $mac < 6 || die "Invalid MAC length";
        if (length $mac == 5) {
            $mac .= pack("W", $$ & 0xff);
        } else {
            $mac = substr($mac . pack("nN", $$ & 0xffff, rand 2**32), 0, 6);
        }
    }
}
$broadcast = 1 if !defined $broadcast && !$server_ip;
my $server_addr = inet_aton($server_ip || "255.255.255.255") ||
    die "Could not resolve server IP '$server_ip'";
$fou = parse_address($fou, "fou receiver", "127.0.0.1") if defined $fou;

socket(my $recv, PF_INET, SOCK_DGRAM, PROTO_UDP) ||
    die "Could not create socket: $^E";
#setsockopt($recv, SOL_SOCKET, SO_BROADCAST, 1) ||
#    die "Could not setsockopt SO_BROADCAST: $^E";
# setsockopt($recv, SOL_SOCKET, SO_REUSEADDR, 1) ||
#    die "Could not setsockopt SO_REUSEADDR: $^E";
my $from = parse_address(
    $listen // "",
    "listen address",
    "0.0.0.0",
    defined $gateway_ip ? BOOTPS : BOOTPC);
if (!bind($recv, $from)) {
    my ($port, $addr) = unpack_sockaddr_in($from);
    my $ip = inet_ntoa($addr);
    die "Could not bind to $ip:$port: $^E";
}
$recv->blocking(0);

my $options1;
for my $try (0..$retries) {
    # DISCOVER
    $mac = packet_send(DISCOVER,
                       $fou, $interface, $server_addr, $xid, $gateway_ip, $mac,
                       $broadcast, $unicast,
                       defined $hostname ? (hostname => $hostname) : ());

    # OFFER
    last if
        $options1 = packet_receive($recv, $timeout, $xid, $expect_addr, $mac);
    print "OFFER receive timed out\n" if $verbose;
}
if (!$options1) {
    print "Max retries reached\n" if $verbose;
    exit 1;
}
$options1->{message_type} == OFFER ||
    die "Unexpected reply type $options1->{message_type} (expected OFFER)";

$xid = int(($xid+1) % 2**32);

my $options2;
for my $try (0..$retries) {
    # REQUEST
    packet_send(REQUEST,
                $fou, $interface,
                $track ? $options1->{server_addr} : $server_addr,
                $xid, $gateway_ip, $mac,
                $track ? 0 : $broadcast, $unicast,
                defined $hostname ? (hostname	=> $hostname) : (),
                request_ip	=> $options1->{your_ip},
                server		=> $options1->{server_addr});

    # ACK
    last if
        $options2 = packet_receive($recv, $timeout, $xid, $options1->{server}, $mac);
    print "ACK receive timed out\n" if $verbose;
}
if (!$options2) {
    print "Max retries reached\n" if $verbose;
    exit 1;
}
$options2->{message_type} == ACK ||
    die "Unexpected reply type $options2->{message_type} (expected ACK)";
print "$separator\n" if $verbose;
print "DHCP Server $options2->{server_ip} gave out $options2->{your_ip}\n";

if (!$keep) {
    # RELEASE
    packet_send(RELEASE,
                $fou, $interface,
                $track ? $options2->{server_addr} : $server_addr,
                $xid, $gateway_ip, $mac,
                $track ? 0 : $broadcast, $unicast,
                defined $hostname ? (hostname	=> $hostname) : (),
                request_ip	=> $options2->{your_ip},
                server		=> $options2->{server_addr});
}
__END__

=head1 NAME

dhcp_test - Do a test DHCP exchange

=head1 SYNOPSIS

 dcp_test [-v|--verbose] [-k|--keep] [-m|-mac [<string>]] [--xid <INT>]
          [-H|--hostname [<string>]] [-e|--expect <IP>] [--fou <ADDRESS>]
          [-s|--server <IP>] [-T|--track] [-i|--interface <string>]
          [-b|--broadcast] [-u|--unicast] [-g|--gateway [<IP>]]
          [-l|--listen <ADDRESS>] [-t|--timeout <FLOAT>] [-r|--retries <INT>]
 dhcp_test [--version] [-U | --unsafe] [-h | --help]

=head1 DESCRIPTION

B<dhcp_test> does a complete exchange with a DHCP server.
Send DHCPDISCOVER, receive DHCPOFFER, send DHCPREQUEST, receive DHCPACK and
send DHCPRELEASE.

=head1 OPTIONS

Valid options are:

=over 4

=item X<verbose>-v, --verbose

Print details about the DHCP exchange

=item X<keep>-k, --keep

Do not release the IP address at the end of the exchange
(don't send the DHCPRELEASE).

=item X<hostname>-H, --hostname I<STRING>

Propose this hostname to the DHCP server. If this option is given but the I<STRING> value is absent or empty it will use the name of the host the program runs
 on.

=item X<mac>-m, --mac I<STRING>

The MAC address what will be sent with the DHCPDISCOVER request. If this option
is not given the MAC address of the sending interface will be used.

The program currently only supports ethernet.

It is valid to pass a too short MAC string. In that case the mac will get padded
with somewhat random bytes. For example using

   --mac 00:00:6C

will generate a MAC address not used by any real device

=item X<xis>--xid I<INT>

Use I<INT> as transaction identifier. Can also be given as an I<IP> which is
then converted to number. If not given an appropiate value is generated
internally.

Transaction IDss are used to match DHCP responses with DHCP requests
(among other things. the program also checks for a MAC address match).

This value will be used for the DHCPDISCOVER request. After selecting a
DHCPOFFER response the value is increased by I<1> (wrapped) and the result is
used for DHCPREQUEST and DHCPRELEASE.

=item X<expect>-e, --expect I<IP>

When DHCPDISCOVER requests are broadcast multiple DHCP servers can answer.
By default the first DHCPOFFER received will be selected to go ahead with.
If this option is given only a DHCPOFFER from the DHCP server with the given
I<IP> will be selected.

The sender of the selected DHCPOFFER (irrespective of the value of this option)
will always be used for DHCP response selection in the following steps.

All DHCP responses (not just DHCPOFFER) are checked for coming from port 67
(irrespective of the value of this option.

=item X<server>-s, --server I<IP>

Send DHCP requests to the given I<IP>. If this option is not given it will
use the broadcast address I<255.255.255.255>.

Notice that L<--expect|/expect> option may still be needed since since the
answers don't always come from from server I<ip>, e.g, with a multihomed DHCP
server.
And there is always a chance that some other DHCP server sends a response which
just happens to match all relevant properties (mostly MAC address and
transaction ID). This is less theoretical than it may seem because some DHCP
servers snoop network traffic and respond to requests even if the request is
specifically not addressed to them.

=item X<interface>-i, --interface I<string>

Bind the sending socket to the named interface (e.g. I<eth0>). This can be
important if you need the packets to be sent over a specific interface.
If this option is not given the operating system will typically send requests
over the interface that the routing table will select for the
L<server|/server> value.

=item X<track>-T, --track

This options modifies the meaning L<--server|/server> value.

The DHCPDISCOVER will still be send to the given L<--server|/server> address,
but all subsequent requests will be directly sent to the DHCP server that sent
the selected DHCPOFFER response.

=item X<broadcast>-b, --broadcast

This option defaults to true if no L<--server|/server> option is give. Otherwise
it defaults to false.

If this option is true the broadcast flag is applied to the socket sending the
DHCPDISCOVER request. This is needed on most operating systems to be allowed
to send a broadcast packet, but this will usually need special permissions
(like being C<root> on unix).

The flag is also used for subsequent requests except if the L<--track|/track>
option is given. In that last case the packets are directly sent to the DHCP
server whose DHCPOFFER was selected, so no broadcast flag is needed.

This option controls request packets. So don't confuse this with the
L<--unicast|/unicast> option which controls response packets.

=item X<unicast>-u, --unicast

By default a flag is set in each DHCP request which requests that the response
gets sent as a broadcast.

If this option is given that flag is not set and as a result the response will
be sent directly to the IP address that gets assigned by the DHCP server. Unless
this is an IP address of the host on which this program is running the program
will not see the response and the DHCP exchange will fail. So only use this
option if you have some cunning plan.

The option will be ignored if the program acts as a DHCP relay (using the
L<--gateway|/gateway> option)

This option (indirectly) controls response packets. So don't confuse this with
the L<--broadcast|/broadcast> option which controls request packets.

=item X<gateway>-g, --gateway I<IP>

The program will behave like a DHCP relay. All requests will use the given I<IP>
as the gateway address. The I<IP> argument is optional. If this option is given
without argument or with an empty argument it will use a local IP address instead (the IP address that
would be used as source for packets to L<sender|/sender>).

If this option is used the DHCP server will send its responses back to I<IP>.
So if this is not a local IP the program will normally not see the DHCP response
so only do that if you have a cunning plan.

Notice that this option is the way you tell a DHCP server to select an address
from a different subnet than the one with the DGCP server address.

=item X<fou>--fou I<ADDRESS>

Send packet using FOU encapsulation (Foo over UDP).

I<ADDRESS> can be given as I<HOST:PORT> or as just a port (number or name) in
which case the host defaults to C<127.0.0.1>.

If this option is given the outgoing packet is encapsulated and then sent to
I<ADDRESS> which is responsible for decapsulating it.

This option allows the program to send packets that it otherwsie cannot
(because the user lacks permission to construct such packets).

=item X<listen>-l, --listen I<ADDRESS>

Listen for responses on I<ADDRESS>.

If this option is not given, it defaults to I<68> unless the
L<gateway|/gateway> option is given in which case it will default to I<67>.
On most operating systems these low port numbers will usually need special
permissions (like being C<root> on unix).

I<ADDRESS> can be given as just a port (number or name) in which case the
program will listen on all addresses or in the form of I<HOST:PORT> in which
case it will listen on that specific I<IP> and I<PORT> combination.

Since you have no control over to which port the DHCP server will send its
responses using this option with a different port will normally mean the program
won't see the response so only use this option if you have a cunning plan.

Packets received on this interface are first checked for FOU encapsulation
(irrespective of the use of the L<--fou|/fou> option). If they are encapsulated
the packet is first decapsulated before further processing.

=item X<timeout>-r, --timeout I<FLOAT>

After sending a DHCP request the program will wait for I<FLOAT> seconds for
a resonse. Defaults to I<1>.

=item X<retries>-r, --retries I<INT>

If the DHCP response times out the program will retry I<INT> more times.
Defaults to I<3>.

=item X<help>-h, --help

Show this help.

=item X<unsafe>-U, --unsafe

Allow even root to run the perldoc.
Remember, the reason this is off by default is because it B<IS> unsafe.

=item X<version>--version

Print version info.

=back

All I<IP> values can also be given as names that will then be resolved.

=head1 EXAMPLE

Simplest use: Do a broadcast, get an IP address assigned and release it

   dhcp_test

The same but with more details about the steps:

   dhcp_test -v

Do the same thing but don't release the assigned IP address at the end:

   dhcp_test -k

The same but function as a DHCP relay:

   dhcp_test -g

Do the DHCP exchange only with a specific DHCP server without broadcast:

   dhcp_test -s IP

Do normal DHCP broadcasts, but only accept offers from a specific DHCP server:

   dhcp_test -e IP

A very complex example:

Send a request on interface C<eth0> (-i) to C<0.0.0.1> (-s) for a host with
randomly generated MAC address C<00:00:6C:XX:XX:XX> (-m) and proposed hostname
C<pluto> (-H) as a DHCP relay that expects an answer to 10.254.0.14 (-g). Only
accept answers from C<10.253.0.8> (-e). Once the DHCP server gives us an IP
address we hold one to it (-k). Send using FOU over port 1237 and listen for
(FOU) answers on port C<1236> (-l)

   dhcp_test -s 0.0.0.1 -e 10.253.0.8 -m 00:00:6C -H pluto -k -g 10.254.0.14 -i eth0 -l 1236 --fou 1237

We assume here we are running on C<10.254.0.8> which is also the host with a
DHCP server (which snoops the otherwise meaningless packets to C<0.0.0.1>). So
we won't seee the answer to C<10.254.0.14> and would normally time out. On linux
we can set up a FOU tunnel that catches the response:

   # Set up FOU tunnel. Notice that we listen on the output port of the tunnel
   ip link add name fou1 type ipip remote 127.0.0.1 local 127.0.0.1 ttl 225 encap fou encap-sport auto encap-dport 1236
   ip addr add 10.253.4.1/24 dev fou1
   # Decapsulator
   ip fou add port 1237 ipproto 4 local 127.0.0.1

   # Allow these weird outgoing FOU packets
   sysctl -w net.ipv4.conf.all.rp_filter=0
   sysctl -w net.ipv4.conf.fou1.rp_filter=0

   # Match DHCP replies about MAC address 00:00:6C:XX:XX:XX
   # Leave operational DHCP replies alone
   iptables -t mangle -A OUTPUT -p udp --dport 67 --sport 67 -m u32 --u32 "4&0x1FFF=0 && 0>>22&0x3C@35&0xffffff=0x6c" -j MARK --set-mark 17

   # Make marked packets use routing plane 101
   ip rule add fwmark 17 lookup 101

   # Route everything in routing plane 101 to the FOU tunnel:
   # ip route add default via 10.253.4.1 table 101

=head1 BUGS

Only supports IPV4

=head1 SEE ALSO

L<dhcpd(8)>,

=head1 AUTHOR

Ton Hospel, E<lt>DHCP-Test@ton.iguana.beE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2021 by Ton Hospel

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.1 or,
at your option, any later version of Perl 5 you may have available.

=cut
