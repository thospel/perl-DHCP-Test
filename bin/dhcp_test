#!/usr/bin/perl -w
# RFC2131: DHCP
# RFC2132: Options
use strict;
use warnings;

our $VERSION = "1.000";

use FindBin qw($Script);
our $Bin;

# If the program runs as /foobar/bin/program, find libraries in /foobar/lib
BEGIN {
    # Even on windows FindBin uses / in the reported path
    $Bin = $FindBin::Bin;
    $Bin =~ s{/+\z}{};
    $Bin =~
        ($^O eq "MSWin32" ?
         qr{^((?:[A-Z]:)?(?:/[a-zA-Z0-9_:.~ -]+)*)/[a-zA-Z0-9_.-]+/*\z} :
         qr{^((?:/[a-zA-Z0-9_:.-]+)*)/[a-zA-Z0-9_.-]+/*\z}) ||
         die "Could not parse bin directory '$Bin'";
    # Use untainted version of lib
    require lib;
    # Support a simple --blib option for pre-install testing
    "lib"->import(@ARGV && $ARGV[0] eq "--blib" ? shift && "$1/blib/lib" : "$1/lib");
}

use Getopt::Long 2.24 qw(:config bundling require_order);
use Socket
    qw(pack_sockaddr_in unpack_sockaddr_in inet_aton inet_ntoa
       PF_INET SOCK_DGRAM SO_REUSEADDR INADDR_ANY INADDR_BROADCAST);
use Sys::Hostname qw(hostname);

use DHCP::Test qw($verbose $separator
                  SO_BINDTODEVICE PROTO_UDP BOOTPC BOOTPS
                  DISCOVER OFFER REQUEST ACK RELEASE
                  OPTION_HOSTNAME OPTION_REQUEST_IP OPTION_SERVER
                  packet_send packet_receive);

# Client chosen ID to match answers
# my $xid = "41.42.43.44";
my $xid = ($$ % 2**16) << 16 | int(rand 2**15) << 1;
my $hostname = hostname();
my $timeout = 1;
my $retries = 4;

die "Could not parse your command line. Try $0 -h\n" unless
    GetOptions("v|verbose!"	=> \$verbose,
               "xid=s"		=> \$xid,
               "r|retries=o"	=> \$retries,
               "t|timeout=f"	=> \$timeout,
               "i|interface=s"	=> \my $interface,
               "m|mac=s"	=> \my $mac,
               "H|hostname=s"	=> \$hostname,
               # do DHCP relay request. Answer is on port 67. Not supported yet
               "g|gateway:s"	=> \my $gateway_ip,
               "u|unicast!"	=> \my $unicast,
               # Do not broadcast but send to specific DHCP server
               "s|server=s"	=> \my $server_ip,
               # Only accept answer from specific DHCP server
               "e|expect=s"	=> \my $expect_ip,
               "k|keep!"	=> \my $keep,
               "version!"	=> \my $version,
               "U|unsafe!"	=> \my $unsafe,
               "h|help!"	=> \my $help);
my $expect_addr = defined $expect_ip ?
    inet_aton($expect_ip) || die("Cannot parse $expect_ip") :
    undef;
$xid = unpack("N", inet_aton($xid));
if (defined $mac) {
    my @mac = map hex, split /:/, $mac;
    @mac == 6 || die "Invalid MAC length";
    $_ <= 0xff || die "Invalid value in MAC" for @mac;
    $mac = pack("W*", @mac);
}
my $server_addr = inet_aton($server_ip || "255.255.255.255") ||
    die "Could not resolve $server_ip";

socket(my $recv, PF_INET, SOCK_DGRAM, PROTO_UDP) ||
    die "Could not create socket: $^E";
#setsockopt($recv, SOL_SOCKET, SO_BROADCAST, 1) ||
#    die "Could not setsockopt SO_BROADCAST: $^E";
# setsockopt($recv, SOL_SOCKET, SO_REUSEADDR, 1) ||
#    die "Could not setsockopt SO_REUSEADDR: $^E";
my $from = pack_sockaddr_in(defined $gateway_ip ? BOOTPS : BOOTPC, INADDR_ANY);
if (!bind($recv, $from)) {
    my ($port, $addr) = unpack_sockaddr_in($from);
    my $ip = inet_ntoa($addr);
    die "Could not bind to $ip:$port: $^E";
}
$recv->blocking(0);

my $options1;
for my $try (1..$retries) {
    # DISCOVER
    $mac = packet_send(DISCOVER,
                       $interface, $server_addr, $xid, $gateway_ip, $mac,
                       $unicast,
                       hostname => $hostname);
    print "$separator\nDISCOVER sent\n" if $verbose;

    # OFFER
    last if
        $options1 = packet_receive($recv, $timeout, $xid, $expect_addr, $mac);
    print "OFFER receive timed out\n" if $verbose;
}
if (!$options1) {
    print "Max retries reached\n" if $verbose;
    exit 1;
}
$options1->{message_type} == OFFER ||
    die "Unexpected reply type $options1->{message_type} (expected OFFER)";

$xid = int(($xid+1) % 2**32);

my $options2;
for my $try (1..$retries) {
    # REQUEST
    packet_send(REQUEST,
                $interface, $server_addr, $xid, $gateway_ip, $mac,
                $unicast,
                hostname	=> $hostname,
                request_ip	=> $options1->{your_ip},
                server	=> $options1->{server_addr});
    print "$separator\nREQUEST sent\n" if $verbose;

    # ACK
    last if
        $options2 = packet_receive($recv, $timeout, $xid, $options1->{server}, $mac);
    print "ACK receive timed out\n" if $verbose;
}
if (!$options2) {
    print "Max retries reached\n" if $verbose;
    exit 1;
}
$options2->{message_type} == ACK ||
    die "Unexpected reply type $options2->{message_type} (expected ACK)";
print "$separator\n" if $verbose;
print "DHCP Server $options2->{server_ip} gave out $options2->{your_ip}\n";

if (!$keep) {
    # RELEASE
    packet_send(RELEASE,
                $interface, $server_addr, $xid, $gateway_ip, $mac,
                $unicast,
                hostname	=> $hostname,
                request_ip	=> $options2->{your_ip},
                server		=> $options2->{server_addr});
    print "$separator\nRELEASE sent\n" if $verbose;
}
